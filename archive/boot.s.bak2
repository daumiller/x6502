; xa -bt0 boot.s -o boot.bin

#define IOC_CMD_ADDR    $0200
#define IOC_RES_ADDR    $0201
#define IOC_CMD_COUNT   $01
#define IO_CMD_RESET    $00
#define IO_CMD_CLASS    $01
#define IO_CMD_VID      $02
#define IO_CMD_PID      $03
#define IO_CMD_NAME     $04
#define IO_CMD_USER     $10
#define CONVID_CMD_PUTC $10
#define PUSHALL   pha : txa : pha : tya : pha
#define POPALL    pla : tay : pla : tax : pla

init:
  jmp $0300   ; $0000 = jmp to page 3
  .dsb $02FD  ; fill first 2 pages with zero

startup:
  sei            ; disable interrupts
  cld            ; disable decimal mode
  ldx #$FF : txs ; initialize stack pointer
  /* initialize zero-page entries */
  ; zp[0|1] == USER
  ; zp[2|3] == IO_PAGE
  lda #$00 : sta $0002
  lda #$02 : sta $0003
  ; zp[4|5] == CONVID
  lda #$00 : sta $0004
  lda #$02 : sta $0005
  ; zp[6|7] == USER
  ; zp[F0-FF] = functions

findConvid:
  ; ioController(IOC_CMD_COUNT)
  lda #IOC_CMD_COUNT
  sta IOC_CMD_ADDR
  lda #0
  pha
  cmp IOC_RES_ADDR
  bne L0000 ; work-around 'halt' out of beq range...
  jmp halt
L0000:
  pla
  cmp IOC_RES_ADDR
  bne L0001 : jmp halt ; "beq halt"
L0001:
  adc #1
  ; addr = IO_PAGE + ((a+1)*16)
  asl : asl : asl : asl
  tay
  lsr : lsr : lsr : lsr
  pha
  lda #IO_CMD_NAME
  sta ($02),Y
  ; compare device's reported name to strConvid
  iny : tya : adc $0002 : sta $0000
              lda $0003 : sta $0001
  lda #<strConvid : sta $0006
  lda #>strConvid : sta $0007
  jsr strCmp
  lda #0 : cmp $00F0 : bne L0000
foundConvid:
  pla
  asl : asl : asl : asl
  sta $0004                  ; store convid ptr in zp[4|5]
  lda #<strHello : sta $0000
  lda #>strHello : sta $0001
  jsr printString
  jmp halt

printString:
  ; zp[0|1] holds string location
  ; zp[4|5] holds convid location
  PUSHALL
  ldy #0
printStringLoop:
  lda ($00),Y
  cmp #0 : beq printStringComplete
  iny : tax : tya : pha : txa ; increment y + push y (preserving a)
  ldy #1 : sta ($04),Y
  ldy #0 : lda #CONVID_CMD_PUTC : sta ($04),Y
  pla : tay
  jmp printStringLoop:
printStringComplete:
  POPALL
  rts

strCmp:
  ; zp[0|1] holds string A
  ; zp[6|7] holds string B
  ; result will be returned in $00F0 (0 - equal, 1 - not equal)
  PUSHALL
  ldy #0
  lda #1 : sta $00F0
strCmpLoop:
  lda ($00),Y
  cmp ($06),Y
  bne strCmpComplete
  iny
  cmp #0
  bne strCmpLoop
  lda #0 : sta $00F0
strCmpComplete:
  POPALL
  rts

strConvid:
  .asc "CONVID" : .byt $00

strHello:
  .asc "Hello Boot World!" : .byt $0A : .byt $00

halt:
  .byt $FF

; jsr
; rts
